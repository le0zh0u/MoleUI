# MoleUI 实现策略快速参考

## 核心原则

**MoleUI 是完全独立的 Swift 应用，不依赖 Mole CLI。**

## 实现方式对比

| 功能 | Mole CLI 实现 | MoleUI 实现 |
|------|--------------|------------|
| 文件扫描 | Shell `find` + `du` | Swift `FileManager.enumerator` |
| 文件删除 | Shell `rm` | Swift `FileManager.removeItem` |
| 应用列表 | Shell `mdfind` | Swift `NSWorkspace` + `FileManager` |
| 系统信息 | Shell `sysctl` + Go `gopsutil` | Swift `IOKit` + `SystemConfiguration` |
| 进程执行 | Shell 直接执行 | Swift `Process` |
| 权限管理 | Shell `sudo` | Swift `SMJobBless` + `Authorization Services` |
| 并发处理 | Shell 后台任务 + Go goroutine | Swift `async/await` + `TaskGroup` |
| 缓存管理 | 文件缓存 | Swift `NSCache` + 文件缓存 |

## 关键 API 映射

### 1. 文件操作

#### Mole CLI
```bash
# 扫描目录
find "$dir" -type f -name "*.log"

# 计算大小
du -sk "$dir"

# 删除文件
rm -rf "$path"
```

#### MoleUI
```swift
// 扫描目录
let enumerator = FileManager.default.enumerator(
    at: url,
    includingPropertiesForKeys: [.fileSizeKey, .contentModificationDateKey]
)

// 计算大小
let attributes = try FileManager.default.attributesOfItem(atPath: path)
let size = attributes[.size] as? Int64

// 删除文件
try FileManager.default.removeItem(at: url)
// 或移至垃圾箱
try FileManager.default.trashItem(at: url, resultingItemURL: nil)
```

### 2. 应用管理

#### Mole CLI
```bash
# 查找应用
mdfind "kMDItemKind == 'Application'"

# 获取应用信息
mdls -name kMDItemDisplayName "$app_path"
```

#### MoleUI
```swift
// 查找应用
let appDirs = ["/Applications", NSHomeDirectory() + "/Applications"]
for dir in appDirs {
    let apps = try FileManager.default.contentsOfDirectory(atPath: dir)
        .filter { $0.hasSuffix(".app") }
}

// 获取应用信息
let bundle = Bundle(url: appURL)
let displayName = bundle?.infoDictionary?["CFBundleDisplayName"] as? String
let bundleID = bundle?.bundleIdentifier

// 获取应用图标
let icon = NSWorkspace.shared.icon(forFile: appPath)
```

### 3. 系统信息

#### Mole CLI
```bash
# CPU 信息
sysctl -n hw.ncpu
sysctl -n machdep.cpu.brand_string

# 内存信息
vm_stat

# 磁盘信息
df -h
```

#### MoleUI
```swift
// CPU 信息
var size = MemoryLayout<host_cpu_load_info>.size
var count = mach_msg_type_number_t(size / MemoryLayout<integer_t>.size)
var hostInfo = host_cpu_load_info()
host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, &hostInfo, &count)

// 内存信息
var vmStats = vm_statistics64()
var count = mach_msg_type_number_t(MemoryLayout<vm_statistics64_data_t>.size / MemoryLayout<integer_t>.size)
host_statistics64(mach_host_self(), HOST_VM_INFO64, &vmStats, &count)

// 磁盘信息
let attributes = try FileManager.default.attributesOfFileSystem(forPath: "/")
let totalSize = attributes[.systemSize] as? Int64
let freeSize = attributes[.systemFreeSize] as? Int64
```

### 4. 进程执行

#### Mole CLI
```bash
# 执行命令
/usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on
```

#### MoleUI
```swift
// 执行命令
let process = Process()
process.executableURL = URL(fileURLWithPath: "/usr/libexec/ApplicationFirewall/socketfilterfw")
process.arguments = ["--setglobalstate", "on"]

let pipe = Pipe()
process.standardOutput = pipe

try process.run()
process.waitUntilExit()

let data = pipe.fileHandleForReading.readDataToEndOfFile()
let output = String(data: data, encoding: .utf8)
```

### 5. 权限管理

#### Mole CLI
```bash
# 请求 sudo
sudo -v

# 执行需要权限的命令
sudo rm -rf /Library/Caches/com.apple.Safari
```

#### MoleUI
```swift
// 请求管理员权限
var authRef: AuthorizationRef?
let status = AuthorizationCreate(nil, nil, [], &authRef)

// 使用 SMJobBless 安装特权助手
var error: Unmanaged<CFError>?
let success = SMJobBless(
    kSMDomainSystemLaunchd,
    "com.mole.helper" as CFString,
    authRef,
    &error
)

// 通过特权助手执行操作
let connection = NSXPCConnection(machServiceName: "com.mole.helper")
connection.remoteObjectInterface = NSXPCInterface(with: PrivilegedHelperProtocol.self)
connection.resume()

let helper = connection.remoteObjectProxy as? PrivilegedHelperProtocol
helper?.deleteFile(atPath: path) { error in
    // 处理结果
}
```

## 并发处理

### Mole CLI
```bash
# 后台任务
for item in "${items[@]}"; do
    process_item "$item" &
    if (( $(jobs -r | wc -l) >= MAX_JOBS )); then
        wait -n
    fi
done
wait
```

### MoleUI
```swift
// 使用 TaskGroup
await withTaskGroup(of: CleanItem.self) { group in
    for category in categories {
        group.addTask {
            await self.scanCategory(category)
        }
    }

    var results: [CleanItem] = []
    for await item in group {
        results.append(item)
    }
    return results
}

// 使用 DispatchQueue
DispatchQueue.concurrentPerform(iterations: items.count) { index in
    processItem(items[index])
}
```

## 缓存策略

### Mole CLI
```bash
# 文件缓存
CACHE_FILE="$HOME/.cache/mole/cache_v1"
if [[ -f "$CACHE_FILE" ]]; then
    source "$CACHE_FILE"
fi
```

### MoleUI
```swift
// NSCache（内存缓存）
class CacheManager {
    private let cache = NSCache<NSString, CacheEntry>()

    func get<T>(_ key: String) -> T? {
        cache.object(forKey: key as NSString)?.value as? T
    }

    func set<T>(_ key: String, value: T, ttl: TimeInterval = 3600) {
        let entry = CacheEntry(value: value, expiresAt: Date().addingTimeInterval(ttl))
        cache.setObject(entry, forKey: key as NSString)
    }
}

// 文件缓存
let cacheURL = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask)[0]
    .appendingPathComponent("com.mole.cache")

let data = try JSONEncoder().encode(cacheData)
try data.write(to: cacheURL)

let loadedData = try Data(contentsOf: cacheURL)
let cacheData = try JSONDecoder().decode(CacheData.self, from: loadedData)
```

## 错误处理

### Mole CLI
```bash
# 错误捕获
set -euo pipefail
trap 'handle_error $? $LINENO' ERR

handle_error() {
    echo "Error at line $2: exit code $1"
    cleanup
    exit "$1"
}
```

### MoleUI
```swift
// Swift 错误处理
enum CleanError: Error {
    case pathNotFound
    case permissionDenied
    case operationFailed(String)
}

func cleanFiles() throws {
    guard FileManager.default.fileExists(atPath: path) else {
        throw CleanError.pathNotFound
    }

    do {
        try FileManager.default.removeItem(atPath: path)
    } catch {
        throw CleanError.operationFailed(error.localizedDescription)
    }
}

// 使用
do {
    try cleanFiles()
} catch CleanError.pathNotFound {
    print("Path not found")
} catch CleanError.permissionDenied {
    print("Permission denied")
} catch {
    print("Unknown error: \(error)")
}
```

## 日志记录

### Mole CLI
```bash
# 日志记录
LOG_FILE="$HOME/.config/mole/operations.log"
echo "[$(date)] [clean] [delete] [$path] [$size]" >> "$LOG_FILE"
```

### MoleUI
```swift
// 使用 os.log
import os.log

let logger = Logger(subsystem: "com.mole.app", category: "clean")

logger.info("Starting clean operation")
logger.debug("Scanning path: \(path)")
logger.error("Failed to delete file: \(error.localizedDescription)")

// 或使用 swift-log
import Logging

let logger = Logger(label: "com.mole.app")

logger.info("Starting clean operation")
logger.debug("Scanning path: \(path)")
logger.error("Failed to delete file: \(error.localizedDescription)")
```

## 性能对比

| 操作 | Mole CLI | MoleUI (预期) |
|------|---------|--------------|
| 扫描 1GB 文件 | ~1秒 | ~1秒 |
| 删除 1000 个文件 | ~2秒 | ~1.5秒 |
| 应用列表加载 | ~0.5秒 | ~0.3秒 |
| 系统信息采集 | ~0.1秒 | ~0.05秒 |
| 内存占用 | 20-50MB | 30-60MB |
| CPU 占用（扫描） | 50-80% | 40-70% |

## 开发建议

### 1. 先实现核心功能
- 文件扫描和删除
- 应用列表和卸载
- 系统信息采集

### 2. 再优化性能
- 并发处理
- 缓存策略
- 内存管理

### 3. 最后完善体验
- UI 动画
- 错误提示
- 进度显示

### 4. 参考但不依赖
- 学习 Mole CLI 的业务逻辑
- 理解清理规则和安全机制
- 借鉴性能优化经验
- 但所有代码用 Swift 重写

## 常见问题

### Q: 为什么不直接调用 Mole CLI？
A:
1. 原生性能更好
2. 可以在 App Store 分发
3. 更好的系统集成
4. 更容易维护

### Q: 如何保证功能一致性？
A:
1. 参考 Mole CLI 的业务逻辑
2. 使用相同的清理规则
3. 实现相同的安全机制
4. 进行充分的测试

### Q: 性能会比 CLI 差吗？
A:
不会。Swift 直接调用系统 API，性能可能更好。关键是：
1. 使用正确的 API
2. 实现并发处理
3. 合理使用缓存
4. 优化内存管理

### Q: 开发周期会更长吗？
A:
可能会稍长，但值得：
1. 更好的用户体验
2. 更容易维护
3. 可以独立发展
4. 可以在 App Store 分发

## 总结

MoleUI 将用 Swift 完全重新实现 Mole CLI 的所有功能。我们将：

1. **学习**：理解 Mole CLI 的业务逻辑
2. **实现**：用 Swift 和 macOS API 重写
3. **优化**：提供更好的性能和体验
4. **独立**：不依赖任何外部工具

这种方式确保了 MoleUI 是一个真正的原生 macOS 应用，提供最佳的用户体验。
