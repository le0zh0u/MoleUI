# MoleUI 架构说明

## 重要说明

**MoleUI 是一个完全独立的 Swift 原生应用，不依赖 Mole CLI 的任何代码。**

所有功能都将使用 Swift 重新实现，包括：
- 文件扫描和清理逻辑
- 系统信息查询
- 磁盘分析算法
- 应用卸载逻辑
- 系统优化操作

## 架构对比

### Mole CLI（参考实现）
```
Shell 脚本 + Go 语言
├── bin/*.sh          # Shell 命令
├── lib/*.sh          # Shell 库
└── cmd/*.go          # Go 程序
```

### MoleUI（独立实现）
```
纯 Swift 实现
├── Services/         # 业务逻辑（Swift）
├── Models/           # 数据模型（Swift）
├── ViewModels/       # 视图模型（Swift）
└── Views/            # UI 界面（SwiftUI）
```

## 为什么独立实现？

### 1. 技术原因
- **原生性能**：Swift 直接调用 macOS API，性能更优
- **类型安全**：Swift 的类型系统提供更好的安全性
- **内存管理**：ARC 自动内存管理，避免内存泄漏
- **并发模型**：Swift Concurrency (async/await) 更现代

### 2. 用户体验
- **无依赖**：不需要安装 Mole CLI
- **沙箱支持**：可以在 App Store 分发
- **权限管理**：使用 macOS 原生权限系统
- **系统集成**：更好的系统集成（通知、菜单栏等）

### 3. 维护性
- **单一代码库**：只需维护 Swift 代码
- **统一测试**：使用 XCTest 统一测试
- **持续集成**：使用 Xcode Cloud 或 GitHub Actions
- **版本管理**：独立的版本号和发布周期

## 功能实现策略

### 从 Mole CLI 学习
Mole CLI 提供了优秀的参考实现，我们将：
1. **学习业务逻辑**：理解清理规则、安全机制
2. **参考算法**：借鉴扫描算法、缓存策略
3. **复用经验**：应用性能优化、错误处理经验

### 用 Swift 重新实现
所有功能都将用 Swift 从零实现：
1. **文件操作**：使用 FileManager
2. **系统信息**：使用 IOKit、SystemConfiguration
3. **进程管理**：使用 Process、NSTask
4. **权限管理**：使用 SMJobBless、Authorization Services

## 核心服务实现

### 1. CleanService（清理服务）
```swift
class CleanService {
    // 扫描系统缓存
    func scanSystemCaches() async -> [CleanItem] {
        // Swift 实现：使用 FileManager 扫描
        let cacheDir = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
        // ... 扫描逻辑
    }

    // 删除文件
    func deleteFiles(_ items: [CleanItem]) async throws {
        // Swift 实现：使用 FileManager 删除
        for item in items {
            try FileManager.default.removeItem(at: item.url)
        }
    }
}
```

### 2. UninstallService（卸载服务）
```swift
class UninstallService {
    // 扫描已安装应用
    func scanApplications() async -> [Application] {
        // Swift 实现：使用 NSWorkspace 和 FileManager
        let appDirs = [
            "/Applications",
            NSHomeDirectory() + "/Applications"
        ]
        // ... 扫描逻辑
    }

    // 查找关联文件
    func findRelatedFiles(for app: Application) async -> [URL] {
        // Swift 实现：根据 Bundle ID 查找
        let searchPaths = [
            "~/Library/Application Support/",
            "~/Library/Preferences/",
            "~/Library/Caches/"
        ]
        // ... 查找逻辑
    }
}
```

### 3. AnalyzeService（分析服务）
```swift
class AnalyzeService {
    // 扫描目录
    func scanDirectory(_ path: String) async -> [DiskEntry] {
        // Swift 实现：使用 FileManager 递归扫描
        var entries: [DiskEntry] = []
        let enumerator = FileManager.default.enumerator(atPath: path)
        // ... 扫描逻辑
    }

    // 计算目录大小
    func calculateSize(of url: URL) async -> Int64 {
        // Swift 实现：使用 FileManager 计算
        var totalSize: Int64 = 0
        // ... 计算逻辑
    }
}
```

### 4. StatusService（监控服务）
```swift
class StatusService {
    // 获取 CPU 信息
    func getCPUInfo() -> CPUMetrics {
        // Swift 实现：使用 sysctl 或 IOKit
        var cpuInfo = host_cpu_load_info()
        // ... 获取逻辑
    }

    // 获取内存信息
    func getMemoryInfo() -> MemoryMetrics {
        // Swift 实现：使用 mach API
        var vmStats = vm_statistics64()
        // ... 获取逻辑
    }
}
```

### 5. OptimizeService（优化服务）
```swift
class OptimizeService {
    // 重建启动服务数据库
    func rebuildLaunchServices() async throws {
        // Swift 实现：使用 Process 执行命令
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister")
        process.arguments = ["-kill", "-r", "-domain", "local", "-domain", "system", "-domain", "user"]
        try process.run()
        process.waitUntilExit()
    }

    // 清理 DNS 缓存
    func flushDNSCache() async throws {
        // Swift 实现：使用 Process 执行命令
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/dscacheutil")
        process.arguments = ["-flushcache"]
        try await executeWithPrivilege(process)
    }
}
```

## 系统 API 使用

### FileManager（文件管理）
```swift
// 枚举文件
let enumerator = FileManager.default.enumerator(at: url, includingPropertiesForKeys: [.fileSizeKey, .contentModificationDateKey])

// 获取文件属性
let attributes = try FileManager.default.attributesOfItem(atPath: path)
let size = attributes[.size] as? Int64

// 删除文件
try FileManager.default.removeItem(at: url)

// 移至垃圾箱
try FileManager.default.trashItem(at: url, resultingItemURL: nil)
```

### NSWorkspace（应用管理）
```swift
// 获取应用列表
let apps = NSWorkspace.shared.runningApplications

// 获取应用图标
let icon = NSWorkspace.shared.icon(forFile: appPath)

// 打开文件
NSWorkspace.shared.open(url)

// 在 Finder 中显示
NSWorkspace.shared.activateFileViewerSelecting([url])
```

### IOKit（硬件信息）
```swift
// 获取 CPU 信息
var size = MemoryLayout<host_cpu_load_info>.size
var count = mach_msg_type_number_t(size / MemoryLayout<integer_t>.size)
var hostInfo = host_cpu_load_info()
host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, &hostInfo, &count)

// 获取电池信息
let snapshot = IOPSCopyPowerSourcesInfo().takeRetainedValue()
let sources = IOPSCopyPowerSourcesList(snapshot).takeRetainedValue() as Array
```

### Process（进程执行）
```swift
// 执行命令
let process = Process()
process.executableURL = URL(fileURLWithPath: "/usr/bin/command")
process.arguments = ["arg1", "arg2"]

let pipe = Pipe()
process.standardOutput = pipe

try process.run()
process.waitUntilExit()

let data = pipe.fileHandleForReading.readDataToEndOfFile()
let output = String(data: data, encoding: .utf8)
```

## 权限管理

### 完全磁盘访问权限
```swift
func checkFullDiskAccess() -> Bool {
    let testPath = "/Library/Application Support"
    return FileManager.default.isReadableFile(atPath: testPath)
}

func requestFullDiskAccess() {
    // 引导用户到系统设置
    let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles")!
    NSWorkspace.shared.open(url)
}
```

### 管理员权限（SMJobBless）
```swift
// 安装特权助手
func installPrivilegedHelper() throws {
    var authRef: AuthorizationRef?
    let status = AuthorizationCreate(nil, nil, [], &authRef)
    guard status == errAuthorizationSuccess else {
        throw PrivilegedHelperError.authorizationFailed
    }

    // 使用 SMJobBless 安装助手
    var error: Unmanaged<CFError>?
    let success = SMJobBless(kSMDomainSystemLaunchd, "com.mole.helper" as CFString, authRef, &error)
    // ...
}
```

## 性能优化

### 并发处理
```swift
// 使用 async/await
func scanCategories() async -> [CleanCategory] {
    await withTaskGroup(of: CleanCategory.self) { group in
        for category in allCategories {
            group.addTask {
                await self.scanCategory(category)
            }
        }

        var results: [CleanCategory] = []
        for await category in group {
            results.append(category)
        }
        return results
    }
}

// 使用 DispatchQueue
DispatchQueue.global(qos: .userInitiated).async {
    // 后台任务
    let result = self.heavyComputation()

    DispatchQueue.main.async {
        // 更新 UI
        self.updateUI(with: result)
    }
}
```

### 缓存策略
```swift
class CacheManager {
    private var cache: [String: CacheEntry] = [:]
    private let queue = DispatchQueue(label: "com.mole.cache", attributes: .concurrent)

    func get<T>(_ key: String) -> T? {
        queue.sync {
            guard let entry = cache[key] else { return nil }
            if entry.isExpired {
                cache.removeValue(forKey: key)
                return nil
            }
            return entry.value as? T
        }
    }

    func set<T>(_ key: String, value: T, ttl: TimeInterval = 3600) {
        queue.async(flags: .barrier) {
            self.cache[key] = CacheEntry(value: value, expiresAt: Date().addingTimeInterval(ttl))
        }
    }
}
```

## 测试策略

### 单元测试
```swift
class CleanServiceTests: XCTestCase {
    func testScanSystemCaches() async throws {
        let service = CleanService()
        let items = await service.scanSystemCaches()

        XCTAssertFalse(items.isEmpty)
        XCTAssertTrue(items.allSatisfy { $0.size >= 0 })
    }
}
```

### UI 测试
```swift
class MoleUITests: XCTestCase {
    func testCleanFlow() throws {
        let app = XCUIApplication()
        app.launch()

        app.buttons["Clean"].tap()
        app.buttons["Start Scan"].tap()

        let resultView = app.otherElements["CleanResult"]
        XCTAssertTrue(resultView.waitForExistence(timeout: 30))
    }
}
```

## 开发工具

### Xcode
- 版本：Xcode 15+
- Swift：5.9+
- 最低系统：macOS 13.0+

### 调试工具
- Instruments：性能分析
- Console.app：日志查看
- Activity Monitor：资源监控

### 版本控制
- Git：代码管理
- GitHub：代码托管
- GitHub Actions：CI/CD

## 总结

MoleUI 是一个完全独立的 Swift 原生应用，不依赖 Mole CLI 的任何代码。我们将：

1. **学习 Mole CLI**：理解业务逻辑和最佳实践
2. **用 Swift 实现**：使用 macOS 原生 API 重新实现所有功能
3. **优化体验**：提供更好的用户体验和系统集成
4. **独立维护**：独立的代码库、版本和发布周期

这种架构确保了：
- ✓ 原生性能和用户体验
- ✓ 更好的系统集成
- ✓ 可以在 App Store 分发
- ✓ 更容易维护和扩展
