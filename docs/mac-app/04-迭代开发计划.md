# MoleUI è¿­ä»£å¼€å‘è®¡åˆ’

## å¼€å‘åŸåˆ™

1. **å°æ­¥å¿«è·‘**ï¼šæ¯ä¸ªè¿­ä»£ 1-2 å‘¨ï¼Œäº§å‡ºå¯è¿è¡Œçš„åŠŸèƒ½
2. **å‚ç›´åˆ‡ç‰‡**ï¼šæ¯ä¸ªè¿­ä»£åŒ…å«å®Œæ•´çš„ UI + é€»è¾‘ + æµ‹è¯•
3. **æŒç»­é›†æˆ**ï¼šæ¯ä¸ªè¿­ä»£ç»“æŸéƒ½èƒ½è¿è¡Œå’Œæ¼”ç¤º
4. **é£é™©ä¼˜å…ˆ**ï¼šå…ˆè§£å†³æŠ€æœ¯éš¾ç‚¹å’Œä¸ç¡®å®šæ€§

## è¿­ä»£æ€»è§ˆ

| è¿­ä»£ | å‘¨æœŸ | æ ¸å¿ƒç›®æ ‡ | äº¤ä»˜ç‰© |
|------|------|---------|--------|
| Sprint 0 | 1å‘¨ | é¡¹ç›®æ­å»º | å¯è¿è¡Œçš„ç©ºå£³åº”ç”¨ |
| Sprint 1 | 2å‘¨ | æ–‡ä»¶æ‰«æåŸºç¡€ | èƒ½æ‰«æå’Œæ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨ |
| Sprint 2 | 2å‘¨ | æ–‡ä»¶åˆ é™¤å’Œæƒé™ | èƒ½å®‰å…¨åˆ é™¤æ–‡ä»¶ |
| Sprint 3 | 2å‘¨ | Clean æ ¸å¿ƒåŠŸèƒ½ | å®Œæ•´çš„æ¸…ç†åŠŸèƒ½ |
| Sprint 4 | 2å‘¨ | Uninstall åŠŸèƒ½ | åº”ç”¨å¸è½½åŠŸèƒ½ |
| Sprint 5 | 1å‘¨ | **Purge é¡¹ç›®æ¸…ç†** | **é¡¹ç›®æ¸…ç†åŠŸèƒ½** â­ |
| Sprint 6 | 2å‘¨ | Analyze åŠŸèƒ½ | ç£ç›˜åˆ†æåŠŸèƒ½ |
| Sprint 7 | 2å‘¨ | Status åŠŸèƒ½ | ç³»ç»Ÿç›‘æ§åŠŸèƒ½ |
| Sprint 8 | 1å‘¨ | Optimize åŠŸèƒ½ | ç³»ç»Ÿä¼˜åŒ–åŠŸèƒ½ |
| Sprint 9 | 1å‘¨ | Installer æ¸…ç† | å®‰è£…åŒ…æ¸…ç†åŠŸèƒ½ |
| Sprint 10 | 2å‘¨ | UI ä¼˜åŒ–å’Œå®Œå–„ | å®Œæ•´çš„ç”¨æˆ·ä½“éªŒ |
| Sprint 11 | 2å‘¨ | æµ‹è¯•å’Œå‘å¸ƒå‡†å¤‡ | å¯å‘å¸ƒçš„ç‰ˆæœ¬ |

**æ€»è®¡**ï¼šçº¦ 18 å‘¨ï¼ˆ4.5 ä¸ªæœˆï¼‰

**ä¼˜å…ˆçº§è°ƒæ•´è¯´æ˜**ï¼š
- âœ… Sprint 5 æ”¹ä¸º Purgeï¼ˆé¡¹ç›®æ¸…ç†ï¼‰ï¼Œæå‰å®ç°
- ğŸ“Š Sprint 6-7 ä¸º Analyze å’Œ Statusï¼ˆå¯è§†åŒ–åŠŸèƒ½ï¼‰
- âš™ï¸ Sprint 8-9 ä¸º Optimize å’Œ Installerï¼ˆè¾…åŠ©åŠŸèƒ½ï¼‰

---

## Sprint 0: é¡¹ç›®æ­å»ºï¼ˆ1å‘¨ï¼‰

### ç›®æ ‡
æ­å»ºåŸºç¡€é¡¹ç›®æ¶æ„ï¼Œå»ºç«‹å¼€å‘ç¯å¢ƒå’Œå·¥ä½œæµç¨‹ã€‚

### ä»»åŠ¡æ¸…å•

#### 1. Xcode é¡¹ç›®åˆ›å»º
- [ ] åˆ›å»º macOS App é¡¹ç›®
- [ ] é…ç½® Bundle ID: `com.mole.MoleUI`
- [ ] è®¾ç½®æœ€ä½ç³»ç»Ÿç‰ˆæœ¬: macOS 13.0
- [ ] é…ç½® App Icon å’ŒåŸºç¡€èµ„æº

#### 2. é¡¹ç›®ç»“æ„æ­å»º
```
MoleUI/
â”œâ”€â”€ MoleUI/
â”‚   â”œâ”€â”€ App/
â”‚   â”‚   â”œâ”€â”€ MoleUIApp.swift
â”‚   â”‚   â””â”€â”€ AppDelegate.swift
â”‚   â”œâ”€â”€ Views/
â”‚   â”‚   â””â”€â”€ MainView.swift
â”‚   â”œâ”€â”€ ViewModels/
â”‚   â”œâ”€â”€ Models/
â”‚   â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Core/
â”‚   â”‚   â”œâ”€â”€ Extensions/
â”‚   â”‚   â””â”€â”€ Utils/
â”‚   â””â”€â”€ Resources/
â””â”€â”€ MoleUITests/
```

#### 3. ä¾èµ–ç®¡ç†
- [ ] é…ç½® Swift Package Manager
- [ ] æ·»åŠ å¿…è¦çš„ä¾èµ–ï¼ˆå¦‚æœéœ€è¦ï¼‰

#### 4. åŸºç¡€ UI æ¡†æ¶
- [ ] åˆ›å»ºä¸»çª—å£ï¼ˆMainViewï¼‰
- [ ] åˆ›å»ºä¾§è¾¹æ å¯¼èˆªï¼ˆSidebarViewï¼‰
- [ ] å®ç°åŸºç¡€å¸ƒå±€ï¼ˆNavigationSplitViewï¼‰

#### 5. å¼€å‘å·¥å…·é…ç½®
- [ ] é…ç½® SwiftLintï¼ˆä»£ç è§„èŒƒï¼‰
- [ ] é…ç½® Git å¿½ç•¥æ–‡ä»¶
- [ ] åˆ›å»º README.md

### éªŒæ”¶æ ‡å‡†
- âœ“ åº”ç”¨èƒ½å¤Ÿå¯åŠ¨å¹¶æ˜¾ç¤ºä¸»çª—å£
- âœ“ ä¾§è¾¹æ æ˜¾ç¤ºæ‰€æœ‰åŠŸèƒ½æ¨¡å—ï¼ˆå ä½ï¼‰
- âœ“ èƒ½å¤Ÿåœ¨ä¸åŒæ¨¡å—é—´åˆ‡æ¢
- âœ“ ä»£ç ç»“æ„æ¸…æ™°ï¼Œç¬¦åˆ MVVM æ¶æ„

### æŠ€æœ¯è¦ç‚¹
```swift
// MoleUIApp.swift
@main
struct MoleUIApp: App {
    var body: some Scene {
        WindowGroup {
            MainView()
                .frame(minWidth: 900, minHeight: 600)
        }
        .windowStyle(.hiddenTitleBar)
        .windowResizability(.contentSize)
    }
}

// MainView.swift
struct MainView: View {
    @State private var selectedTab: Tab = .clean

    enum Tab: String, CaseIterable {
        case clean = "Clean"
        case uninstall = "Uninstall"
        case optimize = "Optimize"
        case analyze = "Analyze"
        case status = "Status"
        case purge = "Purge"
        case installer = "Installer"
    }

    var body: some View {
        NavigationSplitView {
            SidebarView(selection: $selectedTab)
        } detail: {
            DetailView(tab: selectedTab)
        }
    }
}
```

---

## Sprint 1: æ–‡ä»¶æ‰«æåŸºç¡€ï¼ˆ2å‘¨ï¼‰

### ç›®æ ‡
å®ç°åŸºç¡€çš„æ–‡ä»¶æ‰«æåŠŸèƒ½ï¼Œä¸ºåç»­æ‰€æœ‰åŠŸèƒ½æ‰“ä¸‹åŸºç¡€ã€‚

### ä»»åŠ¡æ¸…å•

#### 1. FileScanner æœåŠ¡
- [ ] åˆ›å»º `FileScanner` ç±»
- [ ] å®ç°åŒæ­¥æ‰«ææ–¹æ³•
- [ ] å®ç°å¼‚æ­¥æ‰«ææ–¹æ³•ï¼ˆasync/awaitï¼‰
- [ ] å®ç°è¿›åº¦å›è°ƒ

#### 2. æ–‡ä»¶ä¿¡æ¯æ¨¡å‹
- [ ] åˆ›å»º `FileItem` æ¨¡å‹
- [ ] åŒ…å«ï¼šè·¯å¾„ã€å¤§å°ã€ä¿®æ”¹æ—¶é—´ã€ç±»å‹
- [ ] å®ç° Identifiable å’Œ Hashable

#### 3. æ‰«æç®—æ³•å®ç°
- [ ] é€’å½’ç›®å½•éå†
- [ ] æ–‡ä»¶å¤§å°è®¡ç®—
- [ ] æ–‡ä»¶å±æ€§è¯»å–
- [ ] é”™è¯¯å¤„ç†ï¼ˆæƒé™ä¸è¶³ç­‰ï¼‰

#### 4. æ€§èƒ½ä¼˜åŒ–
- [ ] å¹¶å‘æ‰«æï¼ˆä½¿ç”¨ TaskGroupï¼‰
- [ ] é™åˆ¶å¹¶å‘æ•°é‡
- [ ] å†…å­˜ä¼˜åŒ–ï¼ˆæµå¼å¤„ç†ï¼‰

#### 5. UI å±•ç¤º
- [ ] åˆ›å»ºæ–‡ä»¶åˆ—è¡¨è§†å›¾
- [ ] æ˜¾ç¤ºæ‰«æè¿›åº¦
- [ ] æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯ï¼ˆåç§°ã€å¤§å°ã€è·¯å¾„ï¼‰

### éªŒæ”¶æ ‡å‡†
- âœ“ èƒ½å¤Ÿæ‰«ææŒ‡å®šç›®å½•
- âœ“ æ­£ç¡®è®¡ç®—æ–‡ä»¶å’Œç›®å½•å¤§å°
- âœ“ æ˜¾ç¤ºæ‰«æè¿›åº¦ï¼ˆç™¾åˆ†æ¯”å’Œå½“å‰æ–‡ä»¶ï¼‰
- âœ“ å¤„ç†æƒé™é”™è¯¯å’Œå…¶ä»–å¼‚å¸¸
- âœ“ æ‰«æé€Ÿåº¦ï¼š>1GB/ç§’

### æŠ€æœ¯è¦ç‚¹
```swift
// FileScanner.swift
class FileScanner {
    func scanDirectory(
        at path: String,
        progress: @escaping (Double, String) -> Void
    ) async throws -> [FileItem] {
        var items: [FileItem] = []
        let url = URL(fileURLWithPath: path)

        guard let enumerator = FileManager.default.enumerator(
            at: url,
            includingPropertiesForKeys: [
                .fileSizeKey,
                .contentModificationDateKey,
                .isDirectoryKey
            ]
        ) else {
            throw ScanError.invalidPath
        }

        for case let fileURL as URL in enumerator {
            // è¯»å–æ–‡ä»¶å±æ€§
            let attributes = try fileURL.resourceValues(forKeys: [
                .fileSizeKey,
                .contentModificationDateKey,
                .isDirectoryKey
            ])

            let item = FileItem(
                url: fileURL,
                size: Int64(attributes.fileSize ?? 0),
                modifiedDate: attributes.contentModificationDate ?? Date(),
                isDirectory: attributes.isDirectory ?? false
            )

            items.append(item)

            // æŠ¥å‘Šè¿›åº¦
            progress(Double(items.count), fileURL.path)
        }

        return items
    }
}

// å¹¶å‘æ‰«æ
func scanDirectoriesConcurrently(_ paths: [String]) async throws -> [FileItem] {
    await withTaskGroup(of: [FileItem].self) { group in
        for path in paths {
            group.addTask {
                try await self.scanDirectory(at: path) { _, _ in }
            }
        }

        var allItems: [FileItem] = []
        for await items in group {
            allItems.append(contentsOf: items)
        }
        return allItems
    }
}
```

### é£é™©å’ŒæŒ‘æˆ˜
- **æƒé™é—®é¢˜**ï¼šæŸäº›ç›®å½•éœ€è¦å®Œå…¨ç£ç›˜è®¿é—®æƒé™
- **æ€§èƒ½é—®é¢˜**ï¼šå¤§ç›®å½•æ‰«æå¯èƒ½å¾ˆæ…¢
- **å†…å­˜é—®é¢˜**ï¼šå¤§é‡æ–‡ä»¶å¯èƒ½å ç”¨å¤§é‡å†…å­˜

---

## Sprint 2: æ–‡ä»¶åˆ é™¤å’Œæƒé™ï¼ˆ2å‘¨ï¼‰

### ç›®æ ‡
å®ç°å®‰å…¨çš„æ–‡ä»¶åˆ é™¤åŠŸèƒ½å’Œæƒé™ç®¡ç†ç³»ç»Ÿã€‚

### ä»»åŠ¡æ¸…å•

#### 1. FileDeleter æœåŠ¡
- [ ] åˆ›å»º `FileDeleter` ç±»
- [ ] å®ç°åˆ é™¤å•ä¸ªæ–‡ä»¶
- [ ] å®ç°æ‰¹é‡åˆ é™¤
- [ ] å®ç°ç§»è‡³åƒåœ¾ç®±

#### 2. è·¯å¾„éªŒè¯
- [ ] åˆ›å»º `PathValidator` ç±»
- [ ] å®ç°ç³»ç»Ÿè·¯å¾„ä¿æŠ¤
- [ ] å®ç°ç¬¦å·é“¾æ¥æ£€æŸ¥
- [ ] å®ç°è·¯å¾„éå†æ£€æŸ¥

#### 3. æƒé™ç®¡ç†
- [ ] æ£€æŸ¥å®Œå…¨ç£ç›˜è®¿é—®æƒé™
- [ ] å¼•å¯¼ç”¨æˆ·æˆæƒ
- [ ] å®ç°æƒé™çŠ¶æ€ç›‘æ§

#### 4. å®‰å…¨æœºåˆ¶
- [ ] ç™½åå•ç³»ç»Ÿ
- [ ] åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
- [ ] æ“ä½œæ—¥å¿—è®°å½•

#### 5. UI å®ç°
- [ ] åˆ é™¤ç¡®è®¤å¯¹è¯æ¡†
- [ ] åˆ é™¤è¿›åº¦æ˜¾ç¤º
- [ ] æƒé™è¯·æ±‚ç•Œé¢

### éªŒæ”¶æ ‡å‡†
- âœ“ èƒ½å¤Ÿå®‰å…¨åˆ é™¤æ–‡ä»¶
- âœ“ æ‹’ç»åˆ é™¤ç³»ç»Ÿä¿æŠ¤è·¯å¾„
- âœ“ æ­£ç¡®å¤„ç†æƒé™é”™è¯¯
- âœ“ åˆ é™¤æ“ä½œå¯æ’¤é”€ï¼ˆç§»è‡³åƒåœ¾ç®±ï¼‰
- âœ“ æ‰€æœ‰æ“ä½œéƒ½æœ‰æ—¥å¿—è®°å½•

### æŠ€æœ¯è¦ç‚¹
```swift
// PathValidator.swift
class PathValidator {
    private let protectedPaths = [
        "/System",
        "/bin",
        "/sbin",
        "/usr",
        "/etc",
        "/var/db"
    ]

    func isPathSafe(_ path: String) -> Bool {
        // æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿä¿æŠ¤è·¯å¾„
        for protectedPath in protectedPaths {
            if path.hasPrefix(protectedPath) {
                return false
            }
        }

        // æ£€æŸ¥è·¯å¾„éå†
        if path.contains("/../") {
            return false
        }

        // æ£€æŸ¥ç¬¦å·é“¾æ¥
        if let resolved = try? FileManager.default.destinationOfSymbolicLink(atPath: path) {
            return isPathSafe(resolved)
        }

        return true
    }
}

// FileDeleter.swift
class FileDeleter {
    private let validator = PathValidator()
    private let logger = Logger(subsystem: "com.mole.app", category: "delete")

    func deleteFile(at path: String, moveToTrash: Bool = true) async throws {
        // éªŒè¯è·¯å¾„
        guard validator.isPathSafe(path) else {
            throw DeleteError.unsafePath
        }

        let url = URL(fileURLWithPath: path)

        if moveToTrash {
            // ç§»è‡³åƒåœ¾ç®±
            try FileManager.default.trashItem(at: url, resultingItemURL: nil)
        } else {
            // æ°¸ä¹…åˆ é™¤
            try FileManager.default.removeItem(at: url)
        }

        // è®°å½•æ—¥å¿—
        logger.info("Deleted file: \(path)")
    }
}

// æƒé™æ£€æŸ¥
class PermissionManager {
    func checkFullDiskAccess() -> Bool {
        let testPath = "/Library/Application Support"
        return FileManager.default.isReadableFile(atPath: testPath)
    }

    func requestFullDiskAccess() {
        let url = URL(string: "x-apple.systempreferences:com.apple.preference.security?Privacy_AllFiles")!
        NSWorkspace.shared.open(url)
    }
}
```

### é£é™©å’ŒæŒ‘æˆ˜
- **æƒé™é—®é¢˜**ï¼šéœ€è¦ç”¨æˆ·æ‰‹åŠ¨æˆæƒå®Œå…¨ç£ç›˜è®¿é—®
- **å®‰å…¨é£é™©**ï¼šå¿…é¡»ç¡®ä¿ä¸ä¼šè¯¯åˆ ç³»ç»Ÿæ–‡ä»¶
- **ç”¨æˆ·ä½“éªŒ**ï¼šæƒé™è¯·æ±‚æµç¨‹è¦æ¸…æ™°

---

## Sprint 3: Clean æ ¸å¿ƒåŠŸèƒ½ï¼ˆ2å‘¨ï¼‰

### ç›®æ ‡
å®ç°å®Œæ•´çš„ç³»ç»Ÿæ¸…ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬å¤šä¸ªæ¸…ç†ç±»åˆ«ã€‚

### ä»»åŠ¡æ¸…å•

#### 1. CleanService æœåŠ¡
- [ ] åˆ›å»º `CleanService` ç±»
- [ ] å®ç°æ¸…ç†ç±»åˆ«æšä¸¾
- [ ] å®ç°æ‰«ææ–¹æ³•
- [ ] å®ç°æ¸…ç†æ–¹æ³•

#### 2. æ¸…ç†ç±»åˆ«å®ç°ï¼ˆä¼˜å…ˆçº§æ’åºï¼‰
**ç¬¬ä¸€æ‰¹ï¼ˆæ ¸å¿ƒï¼‰**ï¼š
- [ ] ç”¨æˆ·ç¼“å­˜ï¼ˆ~/Library/Cachesï¼‰
- [ ] ç³»ç»Ÿæ—¥å¿—ï¼ˆ~/Library/Logsï¼‰
- [ ] åƒåœ¾ç®±ï¼ˆ~/.Trashï¼‰

**ç¬¬äºŒæ‰¹ï¼ˆå¸¸ç”¨ï¼‰**ï¼š
- [ ] æµè§ˆå™¨ç¼“å­˜ï¼ˆChrome, Safari, Firefoxï¼‰
- [ ] ä¸‹è½½æ–‡ä»¶å¤¹
- [ ] ä¸´æ—¶æ–‡ä»¶

**ç¬¬ä¸‰æ‰¹ï¼ˆé«˜çº§ï¼‰**ï¼š
- [ ] å¼€å‘å·¥å…·ç¼“å­˜ï¼ˆXcode, npm, Dockerï¼‰
- [ ] åº”ç”¨ç¼“å­˜
- [ ] ç³»ç»Ÿç¼“å­˜

#### 3. CleanViewModel
- [ ] åˆ›å»º `CleanViewModel`
- [ ] å®ç°æ‰«æçŠ¶æ€ç®¡ç†
- [ ] å®ç°æ¸…ç†çŠ¶æ€ç®¡ç†
- [ ] å®ç°è¿›åº¦è·Ÿè¸ª

#### 4. CleanView UI
- [ ] ç±»åˆ«åˆ—è¡¨æ˜¾ç¤º
- [ ] æ‰«æè¿›åº¦æ˜¾ç¤º
- [ ] æ¸…ç†è¿›åº¦æ˜¾ç¤º
- [ ] ç»“æœå±•ç¤º

#### 5. ç™½åå•ç³»ç»Ÿ
- [ ] å®ç°ç™½åå•é…ç½®
- [ ] ç™½åå•ç¼–è¾‘ç•Œé¢
- [ ] é»˜è®¤ç™½åå•

### éªŒæ”¶æ ‡å‡†
- âœ“ èƒ½å¤Ÿæ‰«æè‡³å°‘ 6 ä¸ªæ¸…ç†ç±»åˆ«
- âœ“ æ­£ç¡®è®¡ç®—å¯æ¸…ç†ç©ºé—´
- âœ“ èƒ½å¤Ÿæ‰§è¡Œæ¸…ç†æ“ä½œ
- âœ“ æ˜¾ç¤ºæ¸…ç†å‰åå¯¹æ¯”
- âœ“ ç™½åå•åŠŸèƒ½æ­£å¸¸å·¥ä½œ

### æŠ€æœ¯è¦ç‚¹
```swift
// CleanCategory.swift
enum CleanCategory: String, CaseIterable, Identifiable {
    case userCaches = "User Caches"
    case systemLogs = "System Logs"
    case trash = "Trash"
    case browserCaches = "Browser Caches"
    case downloads = "Downloads"
    case tempFiles = "Temporary Files"

    var id: String { rawValue }

    var description: String {
        switch self {
        case .userCaches:
            return "Application caches in ~/Library/Caches"
        case .systemLogs:
            return "Log files in ~/Library/Logs"
        // ...
        }
    }

    var paths: [String] {
        switch self {
        case .userCaches:
            return [NSHomeDirectory() + "/Library/Caches"]
        case .systemLogs:
            return [NSHomeDirectory() + "/Library/Logs"]
        // ...
        }
    }
}

// CleanService.swift
class CleanService {
    private let scanner = FileScanner()
    private let deleter = FileDeleter()

    func scanCategory(_ category: CleanCategory) async throws -> CleanResult {
        var totalSize: Int64 = 0
        var items: [FileItem] = []

        for path in category.paths {
            let scannedItems = try await scanner.scanDirectory(at: path) { _, _ in }
            items.append(contentsOf: scannedItems)
            totalSize += scannedItems.reduce(0) { $0 + $1.size }
        }

        return CleanResult(
            category: category,
            items: items,
            totalSize: totalSize
        )
    }

    func cleanCategory(_ result: CleanResult) async throws {
        for item in result.items {
            try await deleter.deleteFile(at: item.url.path)
        }
    }
}

// CleanViewModel.swift
@MainActor
class CleanViewModel: ObservableObject {
    @Published var results: [CleanResult] = []
    @Published var isScanning: Bool = false
    @Published var isCleaning: Bool = false
    @Published var scanProgress: Double = 0

    private let service = CleanService()

    func startScan() async {
        isScanning = true
        results = []

        for category in CleanCategory.allCases {
            do {
                let result = try await service.scanCategory(category)
                results.append(result)
                scanProgress = Double(results.count) / Double(CleanCategory.allCases.count)
            } catch {
                print("Error scanning \(category): \(error)")
            }
        }

        isScanning = false
    }

    func clean() async {
        isCleaning = true

        for result in results where result.isSelected {
            try? await service.cleanCategory(result)
        }

        isCleaning = false
    }
}
```

### é£é™©å’ŒæŒ‘æˆ˜
- **æ¸…ç†è§„åˆ™**ï¼šéœ€è¦ä»”ç»†å®šä¹‰æ¯ä¸ªç±»åˆ«çš„æ¸…ç†è§„åˆ™
- **å®‰å…¨æ€§**ï¼šå¿…é¡»ç¡®ä¿ä¸ä¼šè¯¯åˆ é‡è¦æ–‡ä»¶
- **æ€§èƒ½**ï¼šæ‰«æå¤§é‡æ–‡ä»¶å¯èƒ½å¾ˆæ…¢

---

## Sprint 4: Uninstall åŠŸèƒ½ï¼ˆ2å‘¨ï¼‰

### ç›®æ ‡
å®ç°åº”ç”¨å¸è½½åŠŸèƒ½ï¼ŒåŒ…æ‹¬æŸ¥æ‰¾å…³è”æ–‡ä»¶ã€‚

### ä»»åŠ¡æ¸…å•

#### 1. ApplicationScanner æœåŠ¡
- [ ] æ‰«æå·²å®‰è£…åº”ç”¨
- [ ] è¯»å–åº”ç”¨å…ƒæ•°æ®ï¼ˆBundle ID, åç§°, å›¾æ ‡ï¼‰
- [ ] è®¡ç®—åº”ç”¨å¤§å°

#### 2. RelatedFileFinder æœåŠ¡
- [ ] æŸ¥æ‰¾ Application Support
- [ ] æŸ¥æ‰¾ Preferences
- [ ] æŸ¥æ‰¾ Caches
- [ ] æŸ¥æ‰¾ Logs
- [ ] æŸ¥æ‰¾ Launch Agents/Daemons

#### 3. UninstallService
- [ ] å¸è½½åº”ç”¨
- [ ] åˆ é™¤å…³è”æ–‡ä»¶
- [ ] åº”ç”¨ä¿æŠ¤æœºåˆ¶

#### 4. UninstallViewModel å’Œ UI
- [ ] åº”ç”¨åˆ—è¡¨æ˜¾ç¤º
- [ ] åº”ç”¨è¯¦æƒ…æ˜¾ç¤º
- [ ] å…³è”æ–‡ä»¶åˆ—è¡¨
- [ ] å¸è½½è¿›åº¦æ˜¾ç¤º

### éªŒæ”¶æ ‡å‡†
- âœ“ èƒ½å¤Ÿåˆ—å‡ºæ‰€æœ‰å·²å®‰è£…åº”ç”¨
- âœ“ æ˜¾ç¤ºåº”ç”¨å›¾æ ‡å’ŒåŸºæœ¬ä¿¡æ¯
- âœ“ èƒ½å¤ŸæŸ¥æ‰¾å…³è”æ–‡ä»¶
- âœ“ èƒ½å¤Ÿå®Œæ•´å¸è½½åº”ç”¨
- âœ“ ä¿æŠ¤ç³»ç»Ÿå…³é”®åº”ç”¨

### æŠ€æœ¯è¦ç‚¹
```swift
// Application.swift
struct Application: Identifiable {
    let id: UUID
    let name: String
    let bundleID: String
    let path: String
    let icon: NSImage
    let size: Int64
    let lastUsed: Date?
}

// ApplicationScanner.swift
class ApplicationScanner {
    func scanApplications() async -> [Application] {
        let appDirs = [
            "/Applications",
            NSHomeDirectory() + "/Applications"
        ]

        var apps: [Application] = []

        for dir in appDirs {
            guard let contents = try? FileManager.default.contentsOfDirectory(atPath: dir) else {
                continue
            }

            for item in contents where item.hasSuffix(".app") {
                let appPath = dir + "/" + item
                if let app = await scanApplication(at: appPath) {
                    apps.append(app)
                }
            }
        }

        return apps
    }

    private func scanApplication(at path: String) async -> Application? {
        guard let bundle = Bundle(path: path) else { return nil }

        let name = bundle.infoDictionary?["CFBundleDisplayName"] as? String
            ?? bundle.infoDictionary?["CFBundleName"] as? String
            ?? URL(fileURLWithPath: path).deletingPathExtension().lastPathComponent

        let bundleID = bundle.bundleIdentifier ?? ""
        let icon = NSWorkspace.shared.icon(forFile: path)
        let size = calculateSize(of: path)

        return Application(
            id: UUID(),
            name: name,
            bundleID: bundleID,
            path: path,
            icon: icon,
            size: size,
            lastUsed: nil
        )
    }
}
```

---

## Sprint 5: Purge é¡¹ç›®æ¸…ç†åŠŸèƒ½ï¼ˆ1å‘¨ï¼‰â­

### ç›®æ ‡
å®ç°å¼€å‘é¡¹ç›®æ„å»ºäº§ç‰©æ¸…ç†åŠŸèƒ½ï¼Œè¿™æ˜¯å¼€å‘è€…æœ€å¸¸ç”¨çš„åŠŸèƒ½ä¹‹ä¸€ã€‚

### ä¸ºä»€ä¹ˆä¼˜å…ˆå®ç°ï¼Ÿ
1. **é«˜é¢‘ä½¿ç”¨**ï¼šå¼€å‘è€…æ¯å¤©éƒ½éœ€è¦æ¸…ç†é¡¹ç›®
2. **æŠ€æœ¯å¤ç”¨**ï¼šåŸºäº Sprint 1-2 çš„æ–‡ä»¶æ‰«æå’Œåˆ é™¤èƒ½åŠ›
3. **å¿«é€Ÿè§æ•ˆ**ï¼šèƒ½ç«‹å³å›æ”¶å¤§é‡ç©ºé—´ï¼ˆé€šå¸¸ 10-50GBï¼‰
4. **ç”¨æˆ·ä»·å€¼**ï¼šå¯¹å¼€å‘è€…ç”¨æˆ·ä»·å€¼æœ€é«˜

### ä»»åŠ¡æ¸…å•

#### 1. ProjectType æšä¸¾
- [ ] å®šä¹‰æ”¯æŒçš„é¡¹ç›®ç±»å‹
- [ ] æ¯ç§ç±»å‹çš„æ¸…ç†ç›®æ ‡
- [ ] è¯†åˆ«è§„åˆ™

**æŠ€æœ¯è¦ç‚¹**ï¼š
```swift
// ProjectType.swift
enum ProjectType: String, CaseIterable, Identifiable {
    case nodeJS = "Node.js"
    case rust = "Rust"
    case python = "Python"
    case java = "Java"
    case go = "Go"
    case flutter = "Flutter"
    case xcode = "Xcode"
    case ruby = "Ruby"
    case dotnet = ".NET"

    var id: String { rawValue }

    var cleanTargets: [String] {
        switch self {
        case .nodeJS:
            return ["node_modules", ".next", ".nuxt", "dist", "build", ".cache"]
        case .rust:
            return ["target"]
        case .python:
            return ["venv", ".venv", "__pycache__", ".pytest_cache", ".mypy_cache"]
        case .java:
            return ["target", "build", ".gradle"]
        case .go:
            return ["vendor"]
        case .flutter:
            return ["build", ".dart_tool"]
        case .xcode:
            return ["DerivedData", "build", "Pods"]
        case .ruby:
            return ["vendor/bundle"]
        case .dotnet:
            return ["bin", "obj"]
        }
    }

    var identifierFiles: [String] {
        switch self {
        case .nodeJS:
            return ["package.json"]
        case .rust:
            return ["Cargo.toml"]
        case .python:
            return ["requirements.txt", "setup.py", "pyproject.toml"]
        case .java:
            return ["pom.xml", "build.gradle", "build.gradle.kts"]
        case .go:
            return ["go.mod"]
        case .flutter:
            return ["pubspec.yaml"]
        case .xcode:
            return [".xcodeproj", ".xcworkspace"]
        case .ruby:
            return ["Gemfile"]
        case .dotnet:
            return [".csproj", ".sln"]
        }
    }
}
```

#### 2. Project æ¨¡å‹
- [ ] é¡¹ç›®ä¿¡æ¯æ¨¡å‹
- [ ] åŒ…å«é¡¹ç›®è·¯å¾„ã€ç±»å‹ã€å¤§å°ã€æœ€åä¿®æ”¹æ—¶é—´

```swift
// Project.swift
struct Project: Identifiable {
    let id: UUID
    let name: String
    let path: String
    let type: ProjectType
    var cleanableSize: Int64
    let lastModified: Date
    var isRecent: Bool {
        Date().timeIntervalSince(lastModified) < 7 * 24 * 3600 // 7å¤©
    }
}
```

#### 3. ProjectScanner æœåŠ¡
- [ ] æ‰«ææŒ‡å®šç›®å½•
- [ ] è¯†åˆ«é¡¹ç›®ç±»å‹
- [ ] è®¡ç®—å¯æ¸…ç†ç©ºé—´
- [ ] æ£€æŸ¥æœ€åä¿®æ”¹æ—¶é—´

```swift
// ProjectScanner.swift
class ProjectScanner {
    private let fileScanner = FileScanner()

    func scanProjects(in paths: [String]) async throws -> [Project] {
        var projects: [Project] = []

        for path in paths {
            let foundProjects = try await scanDirectory(path)
            projects.append(contentsOf: foundProjects)
        }

        return projects.sorted { $0.cleanableSize > $1.cleanableSize }
    }

    private func scanDirectory(_ path: String) async throws -> [Project] {
        var projects: [Project] = []
        let url = URL(fileURLWithPath: path)

        guard let enumerator = FileManager.default.enumerator(
            at: url,
            includingPropertiesForKeys: [.isDirectoryKey, .contentModificationDateKey],
            options: [.skipsHiddenFiles]
        ) else {
            return []
        }

        for case let fileURL as URL in enumerator {
            // æ£€æŸ¥æ˜¯å¦ä¸ºé¡¹ç›®ç›®å½•
            if let project = try await identifyProject(at: fileURL.path) {
                projects.append(project)
                // è·³è¿‡å­ç›®å½•
                enumerator.skipDescendants()
            }
        }

        return projects
    }

    private func identifyProject(at path: String) async throws -> Project? {
        for type in ProjectType.allCases {
            // æ£€æŸ¥æ ‡è¯†æ–‡ä»¶
            for identifier in type.identifierFiles {
                let identifierPath = path + "/" + identifier
                if FileManager.default.fileExists(atPath: identifierPath) {
                    // æ‰¾åˆ°é¡¹ç›®ï¼Œè®¡ç®—å¯æ¸…ç†å¤§å°
                    let size = try await calculateCleanableSize(at: path, for: type)
                    let attributes = try FileManager.default.attributesOfItem(atPath: path)
                    let modifiedDate = attributes[.modificationDate] as? Date ?? Date()

                    return Project(
                        id: UUID(),
                        name: URL(fileURLWithPath: path).lastPathComponent,
                        path: path,
                        type: type,
                        cleanableSize: size,
                        lastModified: modifiedDate
                    )
                }
            }
        }

        return nil
    }

    private func calculateCleanableSize(at path: String, for type: ProjectType) async throws -> Int64 {
        var totalSize: Int64 = 0

        for target in type.cleanTargets {
            let targetPath = path + "/" + target
            if FileManager.default.fileExists(atPath: targetPath) {
                let size = try await fileScanner.calculateSize(of: targetPath)
                totalSize += size
            }
        }

        return totalSize
    }
}
```

#### 4. PurgeService æœåŠ¡
- [ ] æ¸…ç†é¡¹ç›®
- [ ] æ‰¹é‡æ¸…ç†
- [ ] è¿›åº¦æŠ¥å‘Š

```swift
// PurgeService.swift
class PurgeService {
    private let scanner = ProjectScanner()
    private let deleter = FileDeleter()

    func scanProjects(in paths: [String]) async throws -> [Project] {
        try await scanner.scanProjects(in: paths)
    }

    func purgeProject(_ project: Project) async throws {
        for target in project.type.cleanTargets {
            let targetPath = project.path + "/" + target
            if FileManager.default.fileExists(atPath: targetPath) {
                try await deleter.deleteFile(at: targetPath, moveToTrash: false)
            }
        }
    }

    func purgeProjects(_ projects: [Project], progress: @escaping (Int, Int) -> Void) async throws {
        for (index, project) in projects.enumerated() {
            try await purgeProject(project)
            progress(index + 1, projects.count)
        }
    }
}
```

#### 5. æ‰«æè·¯å¾„é…ç½®
- [ ] é»˜è®¤æ‰«æè·¯å¾„
- [ ] è‡ªå®šä¹‰è·¯å¾„ç®¡ç†
- [ ] è·¯å¾„æŒä¹…åŒ–

```swift
// PurgeConfig.swift
class PurgeConfig {
    static let shared = PurgeConfig()

    private let defaultPaths = [
        NSHomeDirectory() + "/Projects",
        NSHomeDirectory() + "/GitHub",
        NSHomeDirectory() + "/dev",
        NSHomeDirectory() + "/Development",
        NSHomeDirectory() + "/Code",
        NSHomeDirectory() + "/Workspace",
        NSHomeDirectory() + "/Documents/Projects",
        NSHomeDirectory() + "/Documents/GitHub",
        NSHomeDirectory() + "/Documents/dev"
    ]

    @AppStorage("purge_custom_paths") private var customPathsData: Data = Data()

    var scanPaths: [String] {
        if let customPaths = try? JSONDecoder().decode([String].self, from: customPathsData),
           !customPaths.isEmpty {
            return customPaths
        }
        return defaultPaths.filter { FileManager.default.fileExists(atPath: $0) }
    }

    func setCustomPaths(_ paths: [String]) {
        if let data = try? JSONEncoder().encode(paths) {
            customPathsData = data
        }
    }
}
```

#### 6. PurgeViewModel
- [ ] æ‰«æçŠ¶æ€ç®¡ç†
- [ ] é¡¹ç›®åˆ—è¡¨ç®¡ç†
- [ ] é€‰ä¸­çŠ¶æ€ç®¡ç†
- [ ] æ¸…ç†è¿›åº¦ç®¡ç†

```swift
// PurgeViewModel.swift
@MainActor
class PurgeViewModel: ObservableObject {
    @Published var projects: [Project] = []
    @Published var isScanning: Bool = false
    @Published var isPurging: Bool = false
    @Published var scanProgress: Double = 0
    @Published var purgeProgress: (current: Int, total: Int) = (0, 0)
    @Published var selectedProjects: Set<UUID> = []

    private let service = PurgeService()
    private let config = PurgeConfig.shared

    var totalCleanableSize: Int64 {
        projects.filter { selectedProjects.contains($0.id) }
            .reduce(0) { $0 + $1.cleanableSize }
    }

    func startScan() async {
        isScanning = true
        projects = []
        selectedProjects = []

        do {
            let scannedProjects = try await service.scanProjects(in: config.scanPaths)
            projects = scannedProjects

            // é»˜è®¤é€‰ä¸­éæœ€è¿‘é¡¹ç›®
            selectedProjects = Set(scannedProjects.filter { !$0.isRecent }.map { $0.id })
        } catch {
            print("Scan error: \(error)")
        }

        isScanning = false
    }

    func purge() async {
        isPurging = true

        let projectsToPurge = projects.filter { selectedProjects.contains($0.id) }

        do {
            try await service.purgeProjects(projectsToPurge) { current, total in
                self.purgeProgress = (current, total)
            }

            // æ¸…ç†å®Œæˆåé‡æ–°æ‰«æ
            await startScan()
        } catch {
            print("Purge error: \(error)")
        }

        isPurging = false
    }

    func toggleSelection(_ project: Project) {
        if selectedProjects.contains(project.id) {
            selectedProjects.remove(project.id)
        } else {
            selectedProjects.insert(project.id)
        }
    }

    func selectAll() {
        selectedProjects = Set(projects.map { $0.id })
    }

    func deselectAll() {
        selectedProjects = []
    }

    func selectNonRecent() {
        selectedProjects = Set(projects.filter { !$0.isRecent }.map { $0.id })
    }
}
```

#### 7. PurgeView UI
- [ ] é¡¹ç›®åˆ—è¡¨æ˜¾ç¤º
- [ ] æ‰«æè¿›åº¦æ˜¾ç¤º
- [ ] æ¸…ç†è¿›åº¦æ˜¾ç¤º
- [ ] è·¯å¾„é…ç½®ç•Œé¢

```swift
// PurgeView.swift
struct PurgeView: View {
    @StateObject private var viewModel = PurgeViewModel()
    @State private var showingPathConfig = false

    var body: some View {
        VStack(spacing: 0) {
            // å·¥å…·æ 
            HStack {
                Button("Scan Projects") {
                    Task {
                        await viewModel.startScan()
                    }
                }
                .disabled(viewModel.isScanning || viewModel.isPurging)

                Button("Configure Paths") {
                    showingPathConfig = true
                }

                Spacer()

                if !viewModel.projects.isEmpty {
                    Menu("Select") {
                        Button("All") { viewModel.selectAll() }
                        Button("None") { viewModel.deselectAll() }
                        Button("Non-Recent") { viewModel.selectNonRecent() }
                    }

                    Text("Selected: \(FormatUtils.formatSize(viewModel.totalCleanableSize))")
                        .foregroundColor(.secondary)

                    Button("Purge") {
                        Task {
                            await viewModel.purge()
                        }
                    }
                    .disabled(viewModel.selectedProjects.isEmpty || viewModel.isPurging)
                    .buttonStyle(.borderedProminent)
                }
            }
            .padding()

            Divider()

            // å†…å®¹åŒºåŸŸ
            if viewModel.isScanning {
                ProgressView("Scanning projects...")
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if viewModel.isPurging {
                VStack {
                    ProgressView(value: Double(viewModel.purgeProgress.current),
                               total: Double(viewModel.purgeProgress.total))
                    Text("Purging \(viewModel.purgeProgress.current) of \(viewModel.purgeProgress.total)")
                }
                .padding()
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else if viewModel.projects.isEmpty {
                ContentUnavailableView(
                    "No Projects Found",
                    systemImage: "folder.badge.minus",
                    description: Text("Click 'Scan Projects' to find cleanable projects")
                )
            } else {
                ProjectListView(
                    projects: viewModel.projects,
                    selectedProjects: $viewModel.selectedProjects,
                    onToggle: viewModel.toggleSelection
                )
            }
        }
        .sheet(isPresented: $showingPathConfig) {
            PathConfigView()
        }
    }
}

// ProjectListView.swift
struct ProjectListView: View {
    let projects: [Project]
    @Binding var selectedProjects: Set<UUID>
    let onToggle: (Project) -> Void

    var body: some View {
        List(projects) { project in
            ProjectRow(
                project: project,
                isSelected: selectedProjects.contains(project.id),
                onToggle: { onToggle(project) }
            )
        }
    }
}

// ProjectRow.swift
struct ProjectRow: View {
    let project: Project
    let isSelected: Bool
    let onToggle: () -> Void

    var body: some View {
        HStack {
            Button(action: onToggle) {
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .foregroundColor(isSelected ? .blue : .gray)
            }
            .buttonStyle(.plain)

            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(project.name)
                        .font(.headline)

                    if project.isRecent {
                        Text("Recent")
                            .font(.caption)
                            .padding(.horizontal, 6)
                            .padding(.vertical, 2)
                            .background(Color.orange.opacity(0.2))
                            .foregroundColor(.orange)
                            .cornerRadius(4)
                    }
                }

                Text(project.path)
                    .font(.caption)
                    .foregroundColor(.secondary)

                HStack {
                    Text(project.type.rawValue)
                        .font(.caption)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(Color.blue.opacity(0.2))
                        .foregroundColor(.blue)
                        .cornerRadius(4)

                    Text(FormatUtils.formatSize(project.cleanableSize))
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }

            Spacer()
        }
        .padding(.vertical, 4)
    }
}
```

### éªŒæ”¶æ ‡å‡†
- âœ“ èƒ½å¤Ÿæ‰«æé…ç½®çš„ç›®å½•
- âœ“ æ­£ç¡®è¯†åˆ«è‡³å°‘ 6 ç§é¡¹ç›®ç±»å‹
- âœ“ æ­£ç¡®è®¡ç®—å¯æ¸…ç†ç©ºé—´
- âœ“ èƒ½å¤Ÿæ‰§è¡Œæ¸…ç†æ“ä½œ
- âœ“ ä¿æŠ¤æœ€è¿‘ 7 å¤©ä¿®æ”¹çš„é¡¹ç›®ï¼ˆé»˜è®¤ä¸é€‰ä¸­ï¼‰
- âœ“ æ”¯æŒè‡ªå®šä¹‰æ‰«æè·¯å¾„

### é£é™©å’ŒæŒ‘æˆ˜
- **è¯¯åˆ é£é™©**ï¼šå¿…é¡»ç¡®ä¿åªåˆ é™¤æ„å»ºäº§ç‰©
- **æ€§èƒ½é—®é¢˜**ï¼šæ‰«æå¤§é‡é¡¹ç›®å¯èƒ½å¾ˆæ…¢
- **è·¯å¾„é…ç½®**ï¼šç”¨æˆ·å¯èƒ½ä¸çŸ¥é“é¡¹ç›®åœ¨å“ªé‡Œ

---

## Sprint 5-10: åç»­è¿­ä»£

ç”±äºä¼˜å…ˆçº§è°ƒæ•´ï¼Œåç»­è¿­ä»£é¡ºåºæ›´æ–°ä¸ºï¼š

### Sprint 6: Analyze åŠŸèƒ½ï¼ˆ2å‘¨ï¼‰
- ç›®å½•æ ‘æ‰«æ
- å¯è§†åŒ–å±•ç¤ºï¼ˆæ ‘çŠ¶å›¾/é¥¼å›¾ï¼‰
- å¤§æ–‡ä»¶æ£€æµ‹
- äº¤äº’æ“ä½œ

### Sprint 6: Analyze åŠŸèƒ½ï¼ˆ2å‘¨ï¼‰
- ç›®å½•æ ‘æ‰«æ
- å¯è§†åŒ–å±•ç¤ºï¼ˆæ ‘çŠ¶å›¾/é¥¼å›¾ï¼‰
- å¤§æ–‡ä»¶æ£€æµ‹
- äº¤äº’æ“ä½œ

### Sprint 7: Status åŠŸèƒ½ï¼ˆ2å‘¨ï¼‰
- CPU ç›‘æ§
- å†…å­˜ç›‘æ§
- ç£ç›˜ç›‘æ§
- ç½‘ç»œç›‘æ§
- å®æ—¶å›¾è¡¨

### Sprint 8: Optimize åŠŸèƒ½ï¼ˆ1å‘¨ï¼‰
- ç³»ç»Ÿæ£€æŸ¥
- ä¼˜åŒ–å»ºè®®
- ä¸€é”®ä¼˜åŒ–

### Sprint 9: Installer æ¸…ç†ï¼ˆ1å‘¨ï¼‰
- å®‰è£…åŒ…æ‰«æ
- ZIP å†…å®¹æ£€æŸ¥
- æ‰¹é‡åˆ é™¤

### Sprint 10: UI ä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
- åŠ¨ç”»æ•ˆæœ
- äº¤äº’ä¼˜åŒ–
- ä¸»é¢˜æ”¯æŒ

### Sprint 11: æµ‹è¯•å’Œå‘å¸ƒï¼ˆ2å‘¨ï¼‰
- å•å…ƒæµ‹è¯•
- UI æµ‹è¯•
- æ€§èƒ½æµ‹è¯•
- å‘å¸ƒå‡†å¤‡

---

## æ¯ä¸ªè¿­ä»£çš„å·¥ä½œæµç¨‹

### 1. è¿­ä»£å¼€å§‹
- [ ] Sprint Planning ä¼šè®®
- [ ] æ˜ç¡®æœ¬è¿­ä»£ç›®æ ‡
- [ ] åˆ†è§£ä»»åŠ¡
- [ ] ä¼°ç®—å·¥ä½œé‡

### 2. å¼€å‘è¿‡ç¨‹
- [ ] æ¯æ—¥ç«™ä¼šï¼ˆå¯é€‰ï¼‰
- [ ] ä»£ç å®¡æŸ¥
- [ ] æŒç»­é›†æˆ
- [ ] é—®é¢˜è·Ÿè¸ª

### 3. è¿­ä»£ç»“æŸ
- [ ] Sprint Reviewï¼ˆæ¼”ç¤ºï¼‰
- [ ] Sprint Retrospectiveï¼ˆå›é¡¾ï¼‰
- [ ] æ›´æ–°æ–‡æ¡£
- [ ] å‡†å¤‡ä¸‹ä¸€è¿­ä»£

---

## æŠ€æœ¯å€ºåŠ¡ç®¡ç†

### è®°å½•æŠ€æœ¯å€ºåŠ¡
æ¯ä¸ªè¿­ä»£ç»“æŸæ—¶ï¼Œè®°å½•ï¼š
- ä¸´æ—¶è§£å†³æ–¹æ¡ˆ
- éœ€è¦é‡æ„çš„ä»£ç 
- æ€§èƒ½é—®é¢˜
- ç¼ºå¤±çš„æµ‹è¯•

### å¿è¿˜æŠ€æœ¯å€ºåŠ¡
- æ¯ä¸ªè¿­ä»£é¢„ç•™ 20% æ—¶é—´
- ä¼˜å…ˆè§£å†³å½±å“å¤§çš„å€ºåŠ¡
- å®šæœŸé‡æ„

---

## é£é™©ç®¡ç†

### é«˜é£é™©é¡¹
1. **æƒé™ç®¡ç†**ï¼šå¯èƒ½éœ€è¦é¢å¤–æ—¶é—´ç ”ç©¶
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤§æ–‡ä»¶æ‰«æå¯èƒ½å¾ˆæ…¢
3. **ç³»ç»Ÿ API**ï¼šæŸäº› API å¯èƒ½ä¸ç¨³å®š

### åº”å¯¹ç­–ç•¥
- æå‰éªŒè¯æŠ€æœ¯æ–¹æ¡ˆ
- å‡†å¤‡å¤‡é€‰æ–¹æ¡ˆ
- åŠæ—¶è°ƒæ•´è®¡åˆ’

---

## æˆåŠŸæŒ‡æ ‡

### æ¯ä¸ªè¿­ä»£
- âœ“ æ‰€æœ‰ä»»åŠ¡å®Œæˆ
- âœ“ ä»£ç é€šè¿‡å®¡æŸ¥
- âœ“ æµ‹è¯•è¦†ç›–ç‡ > 70%
- âœ“ æ— ä¸¥é‡ Bug

### æ•´ä½“é¡¹ç›®
- âœ“ åŠŸèƒ½å®Œæ•´æ€§ 100%
- âœ“ æ€§èƒ½è¾¾æ ‡
- âœ“ ç”¨æˆ·ä½“éªŒè‰¯å¥½
- âœ“ ä»£ç è´¨é‡é«˜

---

## ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **ç«‹å³å¼€å§‹ Sprint 0**
2. **åˆ›å»º Xcode é¡¹ç›®**
3. **æ­å»ºåŸºç¡€æ¶æ„**
4. **å‡†å¤‡ Sprint 1**

å‡†å¤‡å¥½å¼€å§‹äº†å—ï¼ŸğŸš€
